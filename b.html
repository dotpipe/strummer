<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fretboard Diagram with Sequencer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
        }

        .container {
            max-width: 800px;
            margin: 20px auto;
            padding: 20px;
            background-color: #fff;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            border-radius: 5px;
        }

        .fretboard {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 14px;
            margin-top: 20px;
        }

        .string {
            display: flex;
            justify-content: space-between;
            width: 100%;
            padding: 5px;
        }

        .fret {
            position: relative;
            width: 40px;
            height: 40px;
            border: 1px solid #333;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .fret:hover {
            background-color: #ddd;
        }

        .selected {
            border-radius: 50%;
            /* Make selected squares round */
        }

        .tooltip {
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: #fff;
            padding: 5px 10px;
            border-radius: 4px;
            visibility: hidden;
            opacity: 0;
            transition: visibility 0s, opacity 0.3s linear;
            font-size: 12px;
        }

        .selected:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }

        .interval-root {
            background-color: #ff9999;
            /* Root note color */
        }

        .interval-m2,
        .interval-d2 {
            background-color: #ffcc99;
            /* Minor 2nd color */
        }

        .interval-M2 {
            background-color: #ffff99;
            /* Major 2nd color */
        }

        .interval-m3 {
            background-color: #ccff99;
            /* Minor 3rd color */
        }

        .interval-M3 {
            background-color: #99ff99;
            /* Major 3rd color */
        }

        .interval-P4 {
            background-color: #99ffcc;
            /* Perfect 4th color */
        }

        .interval-d5 {
            background-color: #99ffff;
            /* Diminished 5th color */
        }

        .interval-P5 {
            background-color: #99ccff;
            /* Perfect 5th color */
        }

        .interval-m6 {
            background-color: #9999ff;
            /* Minor 6th color */
        }

        .interval-M6 {
            background-color: #cc99ff;
            /* Major 6th color */
        }

        .interval-m7 {
            background-color: #ff99ff;
            /* Minor 7th color */
        }

        .interval-M7 {
            background-color: #ff99cc;
            /* Major 7th color */
        }

        .controls {
            text-align: center;
            margin-top: 20px;
        }

        .button {
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            background-color: #333;
            color: #fff;
            border: none;
            border-radius: 4px;
        }

        .sequence-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 10px;
        }

        .sequence-step {
            margin: 0 10px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1 style="text-align: center;">Guitar Fretboard Diagram</h1>
        <div class="controls">
            <button id="startAudio" class="button">Start Audio</button>
            <button id="recordSetup" class="button">Record Setup</button>
            <button id="updateSetup" class="button">Update Setup</button>
            <button id="playUpStrum" class="button">Play Up Strum</button>
            <button id="playDownStrum" class="button">Play Down Strum</button>
            <button id="playSequence" class="button">Play Sequence</button>
        </div>
        <div class="sequence-controls">
            <button id="prevStep" class="button">Previous Step</button>
            <span id="currentStep" class="sequence-step">Step: 0</span>
            <button id="nextStep" class="button">Next Step</button>
        </div>
        <div class="stop-save-controls">
            <button onclick="stopPlayback()">Stop Playback</button>
            <input type="file" id="loadSequenceInput" accept=".json" onchange="loadSequence(event)">
            <button onclick="saveSequence()">Save Sequence</button>
        </div>
        <div class="fretboard" id="fretboard">
            <!-- Frets dynamically generated here -->
        </div>
    </div>
    <script>
        let audioContext;
        const selectedNotes = [];
        let recordedSetups = [];
        let currentStep = -1;
        const NUM_FRETS = 24;
        let isPlaying = false; // Flag to track if the sequence is currently playing
        function loadSequence(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                const sequenceData = e.target.result;
                const parsedSequence = JSON.parse(sequenceData);
                loadSongSequence(parsedSequence);
            };
            reader.readAsText(file);
        }
        
        function displaySetup(setup) {
            // Clear previous selections
            const fretElements = document.querySelectorAll('.fret');
            fretElements.forEach(fretElement => {
                fretElement.classList.remove('selected');
                fretElement.classList.remove('note-minor');
                fretElement.classList.remove('note-major');
                removeTooltip(fretElement);
            });

            // Display the new setup
            setup.forEach(note => {
                const fretElement = document.querySelector(`.fret[data-string="${note.string}"][data-fret="${note.fret}"]`);
                if (fretElement) {
                    fretElement.classList.add('selected');
                    const tooltipText = `${note.fret}: ${calculateNoteName(note.string, note.fret)}`;
                    addTooltip(fretElement, tooltipText);
                }
            });
        }

        function loadSongSequence(sequence) {
            // Clear previous recorded setups
            recordedSetups = [];

            // Load new recorded setups
            sequence.forEach(setup => {
                recordedSetups.push(setup);
            });

            // Update UI to display the loaded sequence
            currentStep = 0;
            updateCurrentStepDisplay();
            displaySetup(recordedSetups[currentStep]);
        }

        function stopPlayback() {
            stopAllNotes(); // Stop playing all notes
            isPlaying = false; // Set the flag to indicate playback has stopped
        }

        function saveSequence() {
            const sequenceData = JSON.stringify(recordedSetups);
            const blob = new Blob([sequenceData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'song_sequence.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        document.getElementById('startAudio').addEventListener('click', initAudioContext);
        document.getElementById('recordSetup').addEventListener('click', recordSetup);
        document.getElementById('updateSetup').addEventListener('click', updateSetup);
        document.getElementById('playUpStrum').addEventListener('click', playUpStrum);
        document.getElementById('playDownStrum').addEventListener('click', playDownStrum);
        document.getElementById('playSequence').addEventListener('click', playSequence);
        document.getElementById('prevStep').addEventListener('click', prevStep);
        document.getElementById('nextStep').addEventListener('click', nextStep);

        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                document.getElementById('startAudio').style.display = 'none'; // Hide the button after initializing
                generateFretboard();
            }
        }

        function generateFretboard() {
            for (let string = 0; string < 6; string++) {
                const stringDiv = document.createElement('div');
                stringDiv.className = 'string';

                for (let fret = 0; fret < NUM_FRETS; fret++) {
                    const fretDiv = document.createElement('div');
                    fretDiv.className = 'fret';
                    fretDiv.dataset.string = string;
                    fretDiv.dataset.fret = fret;
                    fretDiv.dataset.note = calculateNoteName(string, fret);
                    fretDiv.classList.add(`note-${calculateNoteName(string, fret)}`);
                    fretDiv.addEventListener('click', toggleNote);
                    stringDiv.appendChild(fretDiv);
                }

                document.getElementById('fretboard').appendChild(stringDiv);
            }
        }

        function calculateNoteName(string, fret) {
            const NOTES = ['E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B', 'C', 'C#', 'D', 'D#'];
            const openStringNotes = ['E', 'B', 'G', 'D', 'A', 'E']; // Note names of open strings
            const baseNoteIndex = NOTES.indexOf(openStringNotes[string]);
            const noteIndex = (baseNoteIndex + fret) % 12;
            return NOTES[noteIndex];
        }

        function calculateFrequency(string, fret) {
            const OPEN_STRING_FREQUENCIES = [329.63, 246.94, 196.00, 146.83, 110.00, 82.41];
            const baseFrequency = OPEN_STRING_FREQUENCIES[string];
            return baseFrequency * Math.pow(2, fret / 12);
        }

        function toggleNote(event) {
            const string = parseInt(event.target.dataset.string);
            const fret = parseInt(event.target.dataset.fret);
            const note = { string, fret };

            const index = findNoteIndex(selectedNotes, note);
            if (index !== -1) {
                // Note already selected, remove it
                selectedNotes.splice(index, 1);
                event.target.classList.remove('selected');
                event.target.className = 'fret'; // Remove all interval classes
                removeTooltip(event.target);
            } else {
                // Note not selected, add it
                selectedNotes.push(note);
                event.target.classList.add('selected');
                addTooltip(event.target);
            }

            // Update all tooltips based on new lowest note
            updateAllTooltips();

            // Play notes in ascending order
            playSelectedNotesAscending();
        }

        function findNoteIndex(array, note) {
            return array.findIndex(item => item.string === note.string && item.fret === note.fret);
        }

        function playSelectedNotesAscending() {
            if (!audioContext) return;

            const sortedNotes = selectedNotes.slice().sort((a, b) => {
                if (a.fret !== b.fret) {
                    return a.fret - b.fret;
                }
                return a.string - b.string;
            });

            // Play sorted notes with a delay between each
            sortedNotes.forEach((note, index) => {
                const frequency = calculateFrequency(note.string, note.fret);
                setTimeout(() => playSoundFrequency(frequency), index * 200);
            });
        }

        function playSelectedNotesDescending() {
            if (!audioContext) return;

            const sortedNotes = selectedNotes.slice().sort((a, b) => {
                if (a.fret !== b.fret) {
                    return b.fret - a.fret;
                }
                return b.string - a.string;
            });

            // Play sorted notes with a delay between each
            sortedNotes.forEach((note, index) => {
                const frequency = calculateFrequency(note.string, note.fret);
                setTimeout(() => playSoundFrequency(frequency), index * 200);
            });
        }

        function stopAllNotes() {
            selectedNotes.forEach(note => {
                stopSound(note);
            });
        }

        function stopSound(note) {
            const oscillator = audioContext.createOscillator();
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(calculateFrequency(note.string, note.fret), audioContext.currentTime);
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.05); // Short stop time to prevent sound
        }

        function playSoundFrequency(frequency) {
            const oscillator = audioContext.createOscillator();
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            const attackTime = 0.05;
            const decayTime = 0.2;
            const sustainLevel = 0.8;
            const releaseTime = 0.3;
            const duration = attackTime + decayTime + releaseTime;
            const endTime = audioContext.currentTime + duration;
            gainNode.gain.linearRampToValueAtTime(1, audioContext.currentTime + attackTime);
            gainNode.gain.linearRampToValueAtTime(sustainLevel, audioContext.currentTime + attackTime + decayTime);
            gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration);
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.start();
            oscillator.stop(endTime);
        }

        function addTooltip(element) {
            const tooltip = document.createElement('div');
            tooltip.className = 'tooltip';
            element.appendChild(tooltip);
        }

        function removeTooltip(element) {
            const tooltip = element.querySelector('.tooltip');
            if (tooltip) {
                element.removeChild(tooltip);
            }
        }

        function updateAllTooltips() {
            const baseNote = selectedNotes.length > 0 ? selectedNotes[0] : null;

            selectedNotes.forEach(note => {
                const fretElement = document.querySelector(`.fret[data-string="${note.string}"][data-fret="${note.fret}"]`);
                if (fretElement) {
                    const tooltip = fretElement.querySelector('.tooltip');
                    if (tooltip) {
                        const interval = calculateInterval(note, baseNote);
                        tooltip.innerText = interval;
                        updateIntervalColor(fretElement, interval);
                    }
                }
            });
        }

        function calculateInterval(note, baseNote) {
            if (!baseNote) return '';

            const NOTES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const baseNoteName = calculateNoteName(baseNote.string, baseNote.fret);
            const noteName = calculateNoteName(note.string, note.fret);

            const baseIndex = NOTES.indexOf(baseNoteName);
            const noteIndex = NOTES.indexOf(noteName);

            let interval = (noteIndex - baseIndex + 12) % 12;
            switch (interval) {
                case 0: return 'Root';
                case 1: return 'm2';
                case 2: return 'M2';
                case 3: return 'm3';
                case 4: return 'M3';
                case 5: return 'P4';
                case 6: return 'd5';
                case 7: return 'P5';
                case 8: return 'm6';
                case 9: return 'M6';
                case 10: return 'm7';
                case 11: return 'M7';
                default: return '';
            }
        }

        function updateIntervalColor(element, interval) {
            element.classList.remove('interval-root', 'interval-m2', 'interval-M2', 'interval-m3', 'interval-M3', 'interval-P4', 'interval-d5', 'interval-P5', 'interval-m6', 'interval-M6', 'interval-m7', 'interval-M7');
            switch (interval) {
                case 'Root':
                    element.classList.add('interval-root');
                    break;
                case 'm2':
                    element.classList.add('interval-m2');
                    break;
                case 'M2':
                    element.classList.add('interval-M2');
                    break;
                case 'm3':
                    element.classList.add('interval-m3');
                    break;
                case 'M3':
                    element.classList.add('interval-M3');
                    break;
                case 'P4':
                    element.classList.add('interval-P4');
                    break;
                case 'd5':
                    element.classList.add('interval-d5');
                    break;
                case 'P5':
                    element.classList.add('interval-P5');
                    break;
                case 'm6':
                    element.classList.add('interval-m6');
                    break;
                case 'M6':
                    element.classList.add('interval-M6');
                    break;
                case 'm7':
                    element.classList.add('interval-m7');
                    break;
                case 'M7':
                    element.classList.add('interval-M7');
                    break;
                default:
                    break;
            }
        }

        function recordSetup() {
            if (selectedNotes.length > 0) {
                const setup = selectedNotes.slice();
                recordedSetups.push(setup);
                currentStep = recordedSetups.length - 1;
                updateCurrentStepDisplay();
                alert('Setup recorded!');
            } else {
                alert('No notes selected to record.');
            }
        }

        function updateSetup() {
            if (currentStep >= 0 && currentStep < recordedSetups.length) {
                if (selectedNotes.length > 0) {
                    recordedSetups[currentStep] = selectedNotes.slice();
                    alert('Setup updated!');
                } else {
                    alert('No notes selected to update.');
                }
            } else {
                alert('No setup selected to update.');
            }
        }

        function playUpStrum() {
            if (selectedNotes.length > 0) {
                playSelectedNotesAscending();
            } else {
                alert('No notes selected to play.');
            }
        }

        function playDownStrum() {
            if (selectedNotes.length > 0) {
                playSelectedNotesDescending();
            } else {
                alert('No notes selected to play.');
            }
        }

        function playSequence() {
            if (recordedSetups.length > 0) {
                recordedSetups.forEach((setup, index) => {
                    setTimeout(() => {
                        playSetup(setup);
                    }, index * 1000); // Play each setup with a delay
                });
            } else {
                alert('No setups recorded.');
            }
        }

        function playSetup(setup) {
            // Clear current selected notes
            selectedNotes.length = 0;
            // Reset fretboard
            const fretElements = document.querySelectorAll('.fret');
            fretElements.forEach(fretElement => {
                fretElement.classList.remove('selected');
                fretElement.className = 'fret'; // Remove all interval classes
                removeTooltip(fretElement);
            });

            // Select notes from setup
            setup.forEach(note => {
                const fretElement = document.querySelector(`.fret[data-string="${note.string}"][data-fret="${note.fret}"]`);
                if (fretElement) {
                    selectedNotes.push(note);
                    fretElement.classList.add('selected');
                    addTooltip(fretElement);
                }
            });

            // Update all tooltips
            updateAllTooltips();

            // Play notes in ascending order
            playSelectedNotesAscending();
        }

        function prevStep() {
            if (currentStep > 0) {
                currentStep--;
                loadSetup(recordedSetups[currentStep]);
                updateCurrentStepDisplay();
            } else {
                alert('No previous step.');
            }
        }

        function nextStep() {
            if (currentStep < recordedSetups.length - 1) {
                currentStep++;
                loadSetup(recordedSetups[currentStep]);
                updateCurrentStepDisplay();
            } else {
                alert('No next step.');
            }
        }

        function loadSetup(setup) {
            // Clear current selected notes
            selectedNotes.length = 0;
            // Reset fretboard
            const fretElements = document.querySelectorAll('.fret');
            fretElements.forEach(fretElement => {
                fretElement.classList.remove('selected');
                fretElement.className = 'fret'; // Remove all interval classes
                removeTooltip(fretElement);
            });

            // Select notes from setup
            setup.forEach(note => {
                const fretElement = document.querySelector(`.fret[data-string="${note.string}"][data-fret="${note.fret}"]`);
                if (fretElement) {
                    selectedNotes.push(note);
                    fretElement.classList.add('selected');
                    addTooltip(fretElement);
                }
            });

            // Update all tooltips
            updateAllTooltips();
        }

        function updateCurrentStepDisplay() {
            document.getElementById('currentStep').innerText = `Step: ${currentStep + 1}`;
        }
    </script>
</body>

</html>